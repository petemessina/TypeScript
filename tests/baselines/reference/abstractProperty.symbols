=== tests/cases/compiler/abstractProperty.ts ===
interface A {
>A : Symbol(A, Decl(abstractProperty.ts, 0, 0))

    prop: string;
>prop : Symbol(prop, Decl(abstractProperty.ts, 0, 13))

    raw: string;
>raw : Symbol(raw, Decl(abstractProperty.ts, 1, 17))

    m(): void;
>m : Symbol(m, Decl(abstractProperty.ts, 2, 16))
}
abstract class B implements A {
>B : Symbol(B, Decl(abstractProperty.ts, 4, 1))
>A : Symbol(A, Decl(abstractProperty.ts, 0, 0))

    abstract prop: string;
>prop : Symbol(prop, Decl(abstractProperty.ts, 5, 31))

    abstract raw: string;
>raw : Symbol(raw, Decl(abstractProperty.ts, 6, 26))

    abstract m(): void;
>m : Symbol(m, Decl(abstractProperty.ts, 7, 25))
}
class C extends B {
>C : Symbol(C, Decl(abstractProperty.ts, 9, 1))
>B : Symbol(B, Decl(abstractProperty.ts, 4, 1))

    get prop() { return "foo"; }
>prop : Symbol(prop, Decl(abstractProperty.ts, 10, 19), Decl(abstractProperty.ts, 11, 32))

    set prop(v) { }
>prop : Symbol(prop, Decl(abstractProperty.ts, 10, 19), Decl(abstractProperty.ts, 11, 32))
>v : Symbol(v, Decl(abstractProperty.ts, 12, 13))

    raw = "edge";
>raw : Symbol(raw, Decl(abstractProperty.ts, 12, 19))

    m() { }
>m : Symbol(m, Decl(abstractProperty.ts, 13, 17))
}
